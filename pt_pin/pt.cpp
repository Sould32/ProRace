/*
 * zproj
 *  emulate PT
 *   record branch infomation (call/branch)
 *   and architecture status
 * Spet 2015 Tong Zhang <ztong@vt.edu>
 */
#include "pin.H"
#include <iostream>

#include <iostream>
#include <fstream>
#include <sstream>
#include <cassert>
#include <iomanip>

using std::stringstream;

KNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, "pintool",
    "-o", "res.log", "specify output file name");

KNOB<BOOL> KnobLog(KNOB_MODE_WRITEONCE, "pintool",
	"-l", "0", "log all instructions");

KNOB<BOOL> KnobFmt(KNOB_MODE_WRITEONCE, "pintool",
	"-f", "0", "emulator input format");

/*
 * log control
 */

BOOL startLog;

/*
 * log file
 */
ofstream logfile;

/*
 * Global Variables
 */

UINT64 ins_count = 0;
CONTEXT tgtCtxt;

//input/output file register file sequence
#define TOTAL_REGS 19
REG regSeq[TOTAL_REGS]=
{
	REG_FLAGS,
	REG_INST_PTR,
	REG_RIP,
	REG_RAX,
	REG_RBX,
	REG_RCX,
	REG_RDX,
	REG_RSI,
	REG_RDI,
	REG_RBP,
	REG_RSP,

	REG_R8,
	REG_R9,
	REG_R10,
	REG_R11,
	REG_R12,
	REG_R13,
	REG_R14,
	REG_R15
};


/*
 * Print Help Message
 */

INT32 Usage()
{
    cerr <<
        "This tool prints out the number of dynamic instructions executed to stderr.\n"
        "\n";

    cerr << KNOB_BASE::StringKnobSummary();

    cerr << endl;

    return -1;
}

/* ===================================================================== */

string Val2Str(const void* value, unsigned int size)
{
    stringstream sstr;
    sstr << hex << setfill('0') << setw(2);
    const unsigned char* cval = (const unsigned char*)value;
    // Traverse cval from end to beginning since the MSB is in the last block of cval.
    while (size)
    {
        --size;
        sstr << setfill('0') << setw(2) << (unsigned int)cval[size];
    }
    return string("0x")+sstr.str();
}


VOID DumpReg(CONTEXT * ctxt, REG reg)
{
	UINT size = REG_Size(reg);
	PIN_REGISTER tgtreg;
	PIN_GetContextRegval( ctxt, reg, reinterpret_cast<UINT8*>(&tgtreg));
	if(KnobFmt)
	{
		logfile <<Val2Str(&tgtreg, size);
	}else
	{
		logfile <<REG_StringShort(reg)<<":" << Val2Str(&tgtreg, size) <<"\t";
	}
}

VOID doRecBranchFrom(CONTEXT * ctxt)
{
	if(!startLog)
		return;
	if(KnobFmt)
		return;
	logfile<<"Branch From:";
	DumpReg(ctxt, REG_INST_PTR);
	logfile<<endl;
	for(int i=0;i<TOTAL_REGS;i++)
	{
		DumpReg(ctxt, regSeq[i]);
		if(i%4==3)
			logfile<<endl;
	}
	logfile<<endl<<"-------"<<endl;
	ins_count++;
}

VOID doRecBranchTo(CONTEXT * ctxt)
{
	if(!startLog)
		return;
	///////////
	if(KnobFmt)
	{
		for(int i=0;i<TOTAL_REGS;i++)
		{
			DumpReg(ctxt, regSeq[i]);
			logfile<<endl;
		}
		return;
	}
	///////////
	logfile<<"Branch To:";
	DumpReg(ctxt, REG_INST_PTR);
	logfile<<endl;
	for(int i=0;i<TOTAL_REGS;i++)
	{
		DumpReg(ctxt, regSeq[i]);
		if(i%4==3)
			logfile<<endl;
	}
	logfile<<endl<<"-------"<<endl;
	ins_count++;
}

VOID Instruction(INS ins, VOID *v)
{
	if(INS_IsBranch(ins))
	{
		/*
		 * predicte instruction
		 */
		INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)doRecBranchFrom, IARG_CONTEXT, IARG_END);
		/*
		 * taken branch
		 */
		INS_InsertCall(ins, IPOINT_TAKEN_BRANCH, (AFUNPTR)doRecBranchTo, IARG_CONTEXT, IARG_END);
		if(INS_Category(ins) == XED_CATEGORY_COND_BR)
		{
			INS_InsertCall(ins, IPOINT_AFTER, (AFUNPTR)doRecBranchTo, IARG_CONTEXT, IARG_END);
		}
		//logfile<<"disass:"<<INS_Disassemble(ins)<<endl;
	}else if(INS_IsCall(ins))
	{
		/*
		 * predicte instruction
		 */
		INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)doRecBranchFrom, IARG_CONTEXT, IARG_END);
		/*
		 * taken branch
		 */
		INS_InsertCall(ins, IPOINT_TAKEN_BRANCH, (AFUNPTR)doRecBranchTo, IARG_CONTEXT, IARG_END);
		//logfile<<"disass:"<<INS_Disassemble(ins)<<endl;
	}
}

VOID LogSwitchTrigger(CONTEXT * ctxt)
{
	startLog = true;
}

static VOID ImgLoad(IMG img, VOID * v)
{
	if (IMG_IsMainExecutable(img))
	{
		RTN mainRtn = RTN_FindByName(img, "main");
		assert(RTN_Valid(mainRtn));
		RTN_Open(mainRtn);
		RTN_InsertCall(mainRtn,
			IPOINT_BEFORE,
			AFUNPTR(LogSwitchTrigger),
			IARG_CONTEXT,
			IARG_END);
		RTN_Close(mainRtn);
	}
}

/* ===================================================================== */

VOID Fini(INT32 code, VOID *v)
{
	logfile<<ins_count<<endl;
	logfile.close();
}

/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */

int main(int argc, char *argv[])
{
    PIN_InitSymbols();
    if( PIN_Init(argc,argv) )
    {
        return Usage();
    }

    if(KnobLog)
    {
    	startLog = true;
    }else
    {
    	startLog = false;
    	IMG_AddInstrumentFunction(ImgLoad, 0);
    }

    logfile.open(KnobOutputFile.Value().c_str());
    //output is generated by ptpin simulator
    logfile<<"0"<<endl;

    INS_AddInstrumentFunction(Instruction, 0);
    PIN_AddFiniFunction(Fini, 0);
    // Never returns
    PIN_StartProgram();
    
    return 0;
}

/* ===================================================================== */
/* eof */
/* ===================================================================== */

